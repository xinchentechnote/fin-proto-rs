// Code generated by fin-protoc. DO NOT EDIT.
use binary_codec::*;
use bytes::{Buf, BufMut, Bytes, BytesMut};

use crate::cancel_reject::*;
use crate::confirm::*;
use crate::exec_rpt_end_of_stream::*;
use crate::exec_rpt_info::*;
use crate::exec_rpt_sync::*;
use crate::exec_rpt_sync_rsp::*;
use crate::heartbeat::*;
use crate::logon::*;
use crate::logout::*;
use crate::new_order_single::*;
use crate::order_cancel::*;
use crate::order_reject::*;
use crate::platform_state::*;
use crate::report::*;

#[derive(Debug, Clone, PartialEq)]
pub enum SseBinaryMsgTypeEnum {
    Heartbeat(Heartbeat),
    Logon(Logon),
    Logout(Logout),
    NewOrderSingle(NewOrderSingle),
    OrderCancel(OrderCancel),
    Confirm(Confirm),
    CancelReject(CancelReject),
    Report(Report),
    OrderReject(OrderReject),
    PlatformState(PlatformState),
    ExecRptInfo(ExecRptInfo),
    ExecRptSync(ExecRptSync),
    ExecRptSyncRsp(ExecRptSyncRsp),
    ExecRptEndOfStream(ExecRptEndOfStream),
}

#[derive(Debug, Clone, PartialEq)]
pub struct SseBinary {
    pub msg_type: u32,
    pub msg_seq_num: u64,
    pub msg_body_len: u32,
    pub msg_type_body: SseBinaryMsgTypeEnum,
    pub checksum: u32,
}

impl BinaryCodec for SseBinary {
    fn encode(&self, buf: &mut BytesMut) {
        buf.put_u32(self.msg_type);
        buf.put_u64(self.msg_seq_num);
        buf.put_u32(self.msg_body_len);
        match &self.msg_type_body {
            SseBinaryMsgTypeEnum::Heartbeat(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::Logon(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::Logout(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::NewOrderSingle(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::OrderCancel(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::Confirm(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::CancelReject(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::Report(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::OrderReject(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::PlatformState(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::ExecRptInfo(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::ExecRptSync(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::ExecRptSyncRsp(msg) => msg.encode(buf),
            SseBinaryMsgTypeEnum::ExecRptEndOfStream(msg) => msg.encode(buf),
        }
        buf.put_u32(self.checksum);
    }

    fn decode(buf: &mut Bytes) -> Option<SseBinary> {
        let msg_type = buf.get_u32();
        let msg_seq_num = buf.get_u64();
        let msg_body_len = buf.get_u32();
        let msg_type_body = match msg_type {
            33 => SseBinaryMsgTypeEnum::Heartbeat(Heartbeat::decode(buf)?),
            40 => SseBinaryMsgTypeEnum::Logon(Logon::decode(buf)?),
            41 => SseBinaryMsgTypeEnum::Logout(Logout::decode(buf)?),
            58 => SseBinaryMsgTypeEnum::NewOrderSingle(NewOrderSingle::decode(buf)?),
            61 => SseBinaryMsgTypeEnum::OrderCancel(OrderCancel::decode(buf)?),
            32 => SseBinaryMsgTypeEnum::Confirm(Confirm::decode(buf)?),
            59 => SseBinaryMsgTypeEnum::CancelReject(CancelReject::decode(buf)?),
            103 => SseBinaryMsgTypeEnum::Report(Report::decode(buf)?),
            204 => SseBinaryMsgTypeEnum::OrderReject(OrderReject::decode(buf)?),
            209 => SseBinaryMsgTypeEnum::PlatformState(PlatformState::decode(buf)?),
            208 => SseBinaryMsgTypeEnum::ExecRptInfo(ExecRptInfo::decode(buf)?),
            206 => SseBinaryMsgTypeEnum::ExecRptSync(ExecRptSync::decode(buf)?),
            207 => SseBinaryMsgTypeEnum::ExecRptSyncRsp(ExecRptSyncRsp::decode(buf)?),
            210 => SseBinaryMsgTypeEnum::ExecRptEndOfStream(ExecRptEndOfStream::decode(buf)?),
            _ => return None,
        };
        let checksum = buf.get_u32();
        Some(Self {
            msg_type,
            msg_seq_num,
            msg_body_len,
            msg_type_body,
            checksum,
        })
    }
}

#[cfg(test)]
mod sse_binary_tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn test_sse_binary_codec() {
        let original = SseBinary {
            msg_seq_num: 123456789,
            msg_body_len: 123456,
            msg_type: 33,
            msg_type_body: SseBinaryMsgTypeEnum::Heartbeat(Heartbeat {}),
            checksum: 123456,
        };

        let mut buf = BytesMut::new();
        original.encode(&mut buf);
        let mut bytes = buf.freeze();

        let decoded = SseBinary::decode(&mut bytes).unwrap();

        assert_eq!(original, decoded);
    }
}
