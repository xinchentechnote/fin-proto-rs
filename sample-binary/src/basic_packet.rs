// Code generated by fin-protoc. DO NOT EDIT.
use binary_codec::*;
use bytes::{Buf, BufMut, Bytes, BytesMut};

#[derive(Debug, Clone, PartialEq)]
pub struct BasicPacket {
    pub field_i_8: i8,
    pub field_i_16: i16,
    pub field_i_32: i32,
    pub field_i_64: i64,
    pub field_char: String,
    pub field_u_8: u8,
    pub field_u_16: u16,
    pub field_u_32: u32,
    pub field_u_64: u64,
    pub field_f_32: f32,
    pub field_f_64: f64,
    pub field_i_8_list: Vec<i8>,
    pub field_i_16_list: Vec<i16>,
    pub field_i_32_list: Vec<i32>,
    pub field_i_64_list: Vec<i64>,
    pub field_char_list: Vec<String>,
    pub field_u_8_list: Vec<u8>,
    pub field_u_16_list: Vec<u16>,
    pub field_u_32_list: Vec<u32>,
    pub field_u_64_list: Vec<u64>,
    pub field_f_32_list: Vec<f32>,
    pub field_f_64_list: Vec<f64>,
}

impl BinaryCodec for BasicPacket {
    fn encode(&self, buf: &mut BytesMut) {
        buf.put_i8(self.field_i_8);
        buf.put_i16_le(self.field_i_16);
        buf.put_i32_le(self.field_i_32);
        buf.put_i64_le(self.field_i_64);
        put_char_array_with_padding(buf, &self.field_char, 1, '0', true);
        buf.put_u8(self.field_u_8);
        buf.put_u16_le(self.field_u_16);
        buf.put_u32_le(self.field_u_32);
        buf.put_u64_le(self.field_u_64);
        buf.put_f32_le(self.field_f_32);
        buf.put_f64_le(self.field_f_64);
        put_list_le::<i8, u16>(buf, &self.field_i_8_list);
        put_list_le::<i16, u16>(buf, &self.field_i_16_list);
        put_list_le::<i32, u16>(buf, &self.field_i_32_list);
        put_list_le::<i64, u16>(buf, &self.field_i_64_list);
        put_fixed_string_list_with_padding_le::<u16>(buf, &self.field_char_list, 1, '0', true);
        put_list_le::<u8, u16>(buf, &self.field_u_8_list);
        put_list_le::<u16, u16>(buf, &self.field_u_16_list);
        put_list_le::<u32, u16>(buf, &self.field_u_32_list);
        put_list_le::<u64, u16>(buf, &self.field_u_64_list);
        put_list_le::<f32, u16>(buf, &self.field_f_32_list);
        put_list_le::<f64, u16>(buf, &self.field_f_64_list);
    }

    fn decode(buf: &mut Bytes) -> Option<BasicPacket> {
        let field_i_8 = buf.get_i8();
        let field_i_16 = buf.get_i16_le();
        let field_i_32 = buf.get_i32_le();
        let field_i_64 = buf.get_i64_le();
        let field_char = get_char_array_trim_padding(buf, 1, '0', true)?;
        let field_u_8 = buf.get_u8();
        let field_u_16 = buf.get_u16_le();
        let field_u_32 = buf.get_u32_le();
        let field_u_64 = buf.get_u64_le();
        let field_f_32 = buf.get_f32_le();
        let field_f_64 = buf.get_f64_le();
        let field_i_8_list = get_list_le::<i8, u16>(buf)?;
        let field_i_16_list = get_list_le::<i16, u16>(buf)?;
        let field_i_32_list = get_list_le::<i32, u16>(buf)?;
        let field_i_64_list = get_list_le::<i64, u16>(buf)?;
        let field_char_list = get_fixed_string_list_trim_padding_le::<u16>(buf, 1, '0', true)?;
        let field_u_8_list = get_list_le::<u8, u16>(buf)?;
        let field_u_16_list = get_list_le::<u16, u16>(buf)?;
        let field_u_32_list = get_list_le::<u32, u16>(buf)?;
        let field_u_64_list = get_list_le::<u64, u16>(buf)?;
        let field_f_32_list = get_list_le::<f32, u16>(buf)?;
        let field_f_64_list = get_list_le::<f64, u16>(buf)?;
        Some(Self {
            field_i_8,
            field_i_16,
            field_i_32,
            field_i_64,
            field_char,
            field_u_8,
            field_u_16,
            field_u_32,
            field_u_64,
            field_f_32,
            field_f_64,
            field_i_8_list,
            field_i_16_list,
            field_i_32_list,
            field_i_64_list,
            field_char_list,
            field_u_8_list,
            field_u_16_list,
            field_u_32_list,
            field_u_64_list,
            field_f_32_list,
            field_f_64_list,
        })
    }
}

#[cfg(test)]
mod basic_packet_tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn test_basic_packet_codec() {
        let original = BasicPacket {
            field_i_8: -42,
            field_i_16: -1234,
            field_i_32: -123456,
            field_i_64: -123456789,
            field_char: vec!['a'; 1].into_iter().collect::<String>(),
            field_u_8: 42,
            field_u_16: 1234,
            field_u_32: 123456,
            field_u_64: 123456789,
            field_f_32: Default::default(),
            field_f_64: Default::default(),
            field_i_8_list: vec![-42, -12],
            field_i_16_list: vec![-1234, -4321],
            field_i_32_list: vec![-123456, -654321],
            field_i_64_list: vec![-123456789, -987654321],
            field_char_list: vec!["a".to_string(); 1],
            field_u_8_list: vec![42, 12],
            field_u_16_list: vec![1234, 4321],
            field_u_32_list: vec![123456, 654321],
            field_u_64_list: vec![123456789, 987654321],
            field_f_32_list: vec![],
            field_f_64_list: vec![],
        };

        let mut buf = BytesMut::new();
        original.encode(&mut buf);
        let mut bytes = buf.freeze();

        let decoded = BasicPacket::decode(&mut bytes).unwrap();
        assert_eq!(original, decoded);
    }
}
