// Code generated by fin-protoc. DO NOT EDIT.
use binary_codec::*;
use bytes::{Buf, BufMut, Bytes, BytesMut};

use crate::basic_packet::*;
use crate::empty_packet::*;
use crate::nested_packet::*;
use crate::string_packet::*;

#[derive(Debug, Clone, PartialEq)]
pub enum RootPacketPayloadEnum {
    BasicPacket(BasicPacket),
    StringPacket(StringPacket),
    NestedPacket(NestedPacket),
    EmptyPacket(EmptyPacket),
}

#[derive(Debug, Clone, PartialEq)]
pub struct RootPacket {
    pub msg_type: u16,
    pub payload_len: u32,
    pub payload: RootPacketPayloadEnum,
    pub checksum: u32,
}

impl BinaryCodec for RootPacket {
    fn encode(&self, buf: &mut BytesMut) {
        buf.put_u16_le(self.msg_type);
        let mut payload_buf = BytesMut::new();
        match &self.payload {
            RootPacketPayloadEnum::BasicPacket(msg) => msg.encode(&mut payload_buf),
            RootPacketPayloadEnum::StringPacket(msg) => msg.encode(&mut payload_buf),
            RootPacketPayloadEnum::NestedPacket(msg) => msg.encode(&mut payload_buf),
            RootPacketPayloadEnum::EmptyPacket(msg) => msg.encode(&mut payload_buf),
        }
        buf.put_u32_le(payload_buf.len() as u32);

        buf.extend_from_slice(&payload_buf);

        let val = CHECKSUM_SERVICE_CONTEXT
            .get("CRC32")
            .and_then(|service| match service.calc(buf) {
                Checksum::U32(v) => Some(v),
                _ => None,
            })
            .unwrap_or(self.checksum);
        buf.put_u32(val);
    }

    fn decode(buf: &mut Bytes) -> Option<RootPacket> {
        let msg_type = buf.get_u16_le();
        let payload_len = buf.get_u32_le();
        let payload = match msg_type {
            1 => RootPacketPayloadEnum::BasicPacket(BasicPacket::decode(buf)?),
            2 => RootPacketPayloadEnum::StringPacket(StringPacket::decode(buf)?),
            3 => RootPacketPayloadEnum::NestedPacket(NestedPacket::decode(buf)?),
            4 => RootPacketPayloadEnum::EmptyPacket(EmptyPacket::decode(buf)?),
            _ => return None,
        };
        let checksum = buf.get_u32_le();
        Some(Self {
            msg_type,
            payload_len,
            payload,
            checksum,
        })
    }
}

#[cfg(test)]
mod root_packet_tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn test_root_packet_codec() {
        let mut original = RootPacket {
            payload_len: 0,
            msg_type: 1,
            payload: RootPacketPayloadEnum::BasicPacket(BasicPacket {
                field_i_8: -42,
                field_i_16: -1234,
                field_i_32: -123456,
                field_i_64: -123456789,
                field_char: vec!['a'; 1].into_iter().collect::<String>(),
                field_u_8: 42,
                field_u_16: 1234,
                field_u_32: 123456,
                field_u_64: 123456789,
                field_f_32: Default::default(),
                field_f_64: Default::default(),
                field_i_8_list: vec![-42, -12],
                field_i_16_list: vec![-1234, -4321],
                field_i_32_list: vec![-123456, -654321],
                field_i_64_list: vec![-123456789, -987654321],
                field_char_list: vec!["a".to_string(); 1],
                field_u_8_list: vec![42, 12],
                field_u_16_list: vec![1234, 4321],
                field_u_32_list: vec![123456, 654321],
                field_u_64_list: vec![123456789, 987654321],
                field_f_32_list: vec![],
                field_f_64_list: vec![],
            }),
            checksum: 123456,
        };

        let mut buf = BytesMut::new();
        original.encode(&mut buf);
        let mut bytes = buf.freeze();

        let decoded = RootPacket::decode(&mut bytes).unwrap();
        original.payload_len = decoded.payload_len;
        original.checksum = decoded.checksum;
        assert_eq!(original, decoded);
    }
}
